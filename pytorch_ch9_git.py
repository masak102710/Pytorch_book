# -*- coding: utf-8 -*-
"""pytorch_ch9_git.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BecPzsM1CcLKlJTuNVU-ZAv5-kveS5sY
"""

def eval_loss(loader,device,net,criterion):
  for images, labels in loader:
    break
  
  inputs = images.to(device)
  labels = labels.to(device)

  outputs = net(inputs)

  loss = criterion(outputs,labels)

  return loss

def fit(net,optimizer,criterion,num_epochs,train_loader,test_loader,device,history):
  for epoch in range(num_epochs):

    base_epochs = len(history)

    # tqdmライブラリのインポート
    from tqdm.notebook import tqdm

    n_train = 0
    loss_train = 0
    acc_train = 0

    for inputs,labels in tqdm(train_loader):
      n_train+= len(labels)
    
      #GPUに転送
      inputs = inputs.to(device)
      labels = labels.to(device)
    
      #勾配初期化
      optimizer.zero_grad()

      #forward計算
      outputs = net(inputs)

      #誤差関数
      loss = criterion(outputs,labels)

      #勾配計算
      loss.backward()

      #パラメータ修正
      optimizer.step()
    
      #精度計算
      loss_train += loss.item()
      
      predicted_train = torch.max(outputs,1)[1]
      acc_train += (predicted_train == labels).sum().item()

    #保存用定義
    n_test = 0
    acc_test = 0
    loss_test2 = 0

    for inputs_test,labels_test in test_loader:
      n_test += len(labels_test)

      #GPUに転送
      inputs_test = inputs_test.to(device)
      labels_test = labels_test.to(device)
    
      #forward計算
      outputs_test = net(inputs_test)
    
      #loss計算
      loss_test1 = criterion(outputs_test,labels_test)

      #精度計算
      predicted_test = torch.max(outputs_test,1)[1]

      loss_test2 += loss_test1.item()
      acc_test += (predicted_test == labels_test).sum().item()
      
    #保存用
    item = [epoch ,loss_train/n_train ,acc_train/n_train ,loss_test2/n_test ,acc_test/n_test]
    history = np.vstack((history,item))
    print(f'回数:{epoch},損失関数(train):{loss_train/n_train}:正答率(train):{acc_train/n_train}')
    print(f'回数:{epoch},損失関数(test ):{loss_test2/n_test}:正答率(test):{acc_test/n_test}')

  return history

def show_image_labels(loader,net,device,classes):

  #loaderからデータ読込
  for images,labels in loader:
    break

  #devise指定あれば転送
  if device is not None:
    images.to(device)
    labels.to(device)

  #forward計算
  if net is not None:
    outputs = net(images)
    predicted = torch.max(outputs,1)[1]

  #image表示
  plt.figure(figsize=(10,5))
  for i in range(50):
    ax = plt.subplot(5,10,i+1)
    plt_image = images[i].numpy() #numpyに変換
    plt_image2 = np.transpose(plt_image,(1,2,0)) #行列の読込方
    plt_image3 = (plt_image2+1)/2 #正規化を戻す
    plt_label = labels[i]

    #ラベル表示,
    if net is not None:
      if(plt_label.item()==predicted[i].item()):
          plt.title(f'{classes[predicted[i]]}') #正解
      else:
          plt.title(f'{classes[predicted[i]]}',color='red') #不正解
    else:
      plt.title(f'{classes[plt_label]}') #netない場合
    
    plt.imshow(plt_image3)
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
    plt.tight_layout()
  plt.show()

def plot_history(history):
  plt.plot(history[:,0],history[:,1],label = 'test') #loss_test
  plt.plot(history[:,0],history[:,3],label = 'train') #train_test

  plt.xlabel('epoch')
  plt.ylabel('loss')
  plt.title('loss',fontsize = 18)
  plt.legend(fontsize = 18)
  
  plt.show()


  plt.plot(history[:,0],history[:,2],label = 'test') #acc_test
  plt.plot(history[:,0],history[:,4],label = 'train') #train_test
  
  plt.xlabel('epoch')
  plt.ylabel('acc')
  plt.title('acc',fontsize = 18)
  plt.legend(fontsize = 18)
  
  plt.ylim(0,1)
  plt.show()